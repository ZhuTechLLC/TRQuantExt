import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)






import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)




import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)

import logging
import os
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

from ptrade_bridge.models import (
    Strategy,
    BacktestResult,
    BacktestMetric,
    EquityPoint,
    Trade,
)

logger = logging.getLogger(__name__)


class BaseBridgeService:
    """
    多平台桥接器基础服务

    负责：
    - 扫描策略目录
    - 加载回测/交易数据
    - 监听文件变化并刷新缓存
    """

    def __init__(
        self,
        platform: str,
        strategy_dir: Path,
        data_dir: Path,
        enable_watchdog: bool = True,
    ):
        self.platform = platform
        self.strategy_dir = Path(strategy_dir)
        self.data_dir = Path(data_dir)
        self.backtest_dir = self.data_dir / "backtest_results"
        self.trades_dir = self.data_dir / "trades"

        for path in [self.strategy_dir, self.backtest_dir, self.trades_dir]:
            path.mkdir(parents=True, exist_ok=True)

        self.strategies: Dict[str, Strategy] = {}
        self.backtests: Dict[str, BacktestResult] = {}
        self.trades: Dict[str, Trade] = {}

        self._load_all()

        self.observer: Optional[Observer] = None
        if enable_watchdog:
            self._init_watchdog()

    # ------------------------------------------------------------------ #
    # 数据加载
    # ------------------------------------------------------------------ #

    def _load_all(self):
        self._load_strategies()
        self._load_backtests()
        self._load_trades()
        logger.info("[%s] 加载完成: 策略=%s 回测=%s 交易=%s",
                    self.platform,
                    len(self.strategies),
                    len(self.backtests),
                    len(self.trades))

    def _load_strategies(self):
        self.strategies.clear()
        for file in self.strategy_dir.glob("*.py"):
            strategy_id = file.stem
            self.strategies[strategy_id] = Strategy(
                id=strategy_id,
                name=strategy_id.replace("_", " ").title(),
                broker=self.platform,
                file_path=str(file),
                description=self._extract_description(file),
                created_at=datetime.fromtimestamp(file.stat().st_ctime),
                updated_at=datetime.fromtimestamp(file.stat().st_mtime),
            )

    def _extract_description(self, file: Path) -> str:
        try:
            with open(file, "r", encoding="utf-8") as f:
                for _ in range(10):
                    line = f.readline()
                    if not line:
                        break
                    line = line.strip().strip("#").strip()
                    if line:
                        return line[:120]
        except Exception:
            pass
        return f"{self.platform} Strategy"

    def _load_backtests(self):
        self.backtests.clear()
        for json_file in self.backtest_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                backtest = self._parse_backtest(data, json_file)
                self.backtests[backtest.id] = backtest
            except Exception as e:
                logger.warning("[%s] 解析回测失败 %s: %s", self.platform, json_file.name, e)

    def _parse_backtest(self, data: Dict, file: Path) -> BacktestResult:
        metrics = data.get("metrics", {})
        metric_obj = BacktestMetric(**metrics) if isinstance(metrics, dict) else BacktestMetric()

        equity_curve = [
            EquityPoint(**point) if isinstance(point, dict) else point
            for point in data.get("equity_curve", [])
        ]

        return BacktestResult(
            id=data.get("id", file.stem),
            strategy_id=data.get("strategy_id", data.get("strategy_name", "unknown")),
            strategy_name=data.get("strategy_name", data.get("strategy_id", "unknown")),
            start_date=data.get("start_date", ""),
            end_date=data.get("end_date", ""),
            initial_cash=data.get("initial_cash", 0.0),
            final_cash=data.get("final_cash", data.get("final_capital", 0.0)),
            metrics=metric_obj,
            equity_curve=equity_curve,
            trades=data.get("trades", []),
        )

    def _load_trades(self):
        self.trades.clear()
        for json_file in self.trades_dir.glob("*.json"):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    items = json.load(f)
                if isinstance(items, dict):
                    items = items.get("trades", [])
                for item in items:
                    trade = Trade(**item)
                    self.trades[trade.trade_id] = trade
            except Exception as e:
                logger.warning("[%s] 解析交易失败 %s: %s", self.platform, json_file.name, e)

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #

    def get_strategies(self) -> List[Strategy]:
        return list(self.strategies.values())

    def get_strategy(self, strategy_id: str) -> Optional[Strategy]:
        return self.strategies.get(strategy_id)

    def get_backtests(self, strategy_id: Optional[str] = None) -> List[BacktestResult]:
        if strategy_id:
            return [bt for bt in self.backtests.values() if bt.strategy_id == strategy_id]
        return list(self.backtests.values())

    def get_backtest(self, backtest_id: str) -> Optional[BacktestResult]:
        return self.backtests.get(backtest_id)

    def get_trades(self, strategy_id: Optional[str] = None) -> List[Trade]:
        if strategy_id:
            return [t for t in self.trades.values() if t.strategy_id == strategy_id]
        return list(self.trades.values())

    def refresh(self):
        self._load_all()

    # ------------------------------------------------------------------ #
    # Watchdog
    # ------------------------------------------------------------------ #

    def _init_watchdog(self):
        handler = _BridgeWatcher(self)
        observer = Observer()
        observer.schedule(handler, str(self.strategy_dir), recursive=False)
        observer.schedule(handler, str(self.backtest_dir), recursive=False)
        observer.schedule(handler, str(self.trades_dir), recursive=False)
        observer.start()
        self.observer = observer
        logger.info("[%s] Watchdog 已启动", self.platform)

    def stop(self):
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("[%s] Watchdog 已停止", self.platform)


class _BridgeWatcher(FileSystemEventHandler):
    def __init__(self, service: BaseBridgeService):
        self.service = service

    def on_any_event(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix == ".py":
            self.service._load_strategies()
        elif "backtest" in path.name:
            self.service._load_backtests()
        else:
            self.service._load_trades()
        logger.debug("[%s] 检测到文件变化，已刷新缓存", self.service.platform)














