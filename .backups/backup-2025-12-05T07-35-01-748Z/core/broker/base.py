# -*- coding: utf-8 -*-
"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids






"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids




"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids

"""
券商接口基类
定义统一的交易接口规范
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class BrokerStatus(Enum):
    """券商连接状态"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"


class OrderStatus(Enum):
    """订单状态"""
    PENDING = "pending"          # 待报
    SUBMITTED = "submitted"      # 已报
    PARTIAL_FILLED = "partial"   # 部分成交
    FILLED = "filled"            # 全部成交
    CANCELLED = "cancelled"      # 已撤
    REJECTED = "rejected"        # 废单
    UNKNOWN = "unknown"          # 未知


class OrderSide(Enum):
    """交易方向"""
    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """订单类型"""
    MARKET = "market"            # 市价单
    LIMIT = "limit"              # 限价单
    BEST = "best"                # 最优五档


@dataclass
class Order:
    """订单数据"""
    order_id: str                        # 订单ID
    stock_code: str                      # 股票代码
    side: OrderSide                      # 买卖方向
    order_type: OrderType                # 订单类型
    price: float                         # 委托价格
    quantity: int                        # 委托数量
    filled_quantity: int = 0             # 成交数量
    filled_price: float = 0.0            # 成交均价
    status: OrderStatus = OrderStatus.PENDING
    create_time: datetime = field(default_factory=datetime.now)
    update_time: datetime = field(default_factory=datetime.now)
    message: str = ""                    # 状态信息
    
    @property
    def is_active(self) -> bool:
        """订单是否活跃"""
        return self.status in [OrderStatus.PENDING, OrderStatus.SUBMITTED, OrderStatus.PARTIAL_FILLED]
    
    @property
    def is_completed(self) -> bool:
        """订单是否完成"""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.REJECTED]


@dataclass
class Position:
    """持仓数据"""
    stock_code: str                      # 股票代码
    stock_name: str = ""                 # 股票名称
    quantity: int = 0                    # 持仓数量
    available: int = 0                   # 可用数量
    cost_price: float = 0.0              # 成本价
    current_price: float = 0.0           # 现价
    market_value: float = 0.0            # 市值
    profit: float = 0.0                  # 盈亏
    profit_ratio: float = 0.0            # 盈亏比例
    
    def update_price(self, price: float):
        """更新现价"""
        self.current_price = price
        self.market_value = self.quantity * price
        if self.cost_price > 0:
            self.profit = (price - self.cost_price) * self.quantity
            self.profit_ratio = (price - self.cost_price) / self.cost_price


@dataclass
class Account:
    """账户数据"""
    account_id: str = ""                 # 账户ID
    account_type: str = ""               # 账户类型
    total_asset: float = 0.0             # 总资产
    cash: float = 0.0                    # 可用资金
    frozen: float = 0.0                  # 冻结资金
    market_value: float = 0.0            # 持仓市值
    profit: float = 0.0                  # 总盈亏
    profit_ratio: float = 0.0            # 盈亏比例


class IBroker(ABC):
    """
    券商接口抽象基类
    定义统一的交易接口规范，支持QMT和PTrade
    """
    
    def __init__(self, name: str = "BaseBroker"):
        self.name = name
        self._status = BrokerStatus.DISCONNECTED
        self._account: Optional[Account] = None
        self._positions: Dict[str, Position] = {}
        self._orders: Dict[str, Order] = {}
        self._callbacks: Dict[str, List[Callable]] = {
            'on_connected': [],
            'on_disconnected': [],
            'on_order_update': [],
            'on_trade': [],
            'on_position_update': [],
            'on_account_update': [],
            'on_error': [],
        }
        logger.info(f"初始化券商接口: {name}")
    
    @property
    def status(self) -> BrokerStatus:
        """获取连接状态"""
        return self._status
    
    @property
    def is_connected(self) -> bool:
        """是否已连接"""
        return self._status == BrokerStatus.CONNECTED
    
    # ==================== 连接管理 ====================
    
    @abstractmethod
    def connect(self, **kwargs) -> bool:
        """
        连接券商服务器
        
        Args:
            **kwargs: 连接参数（账号、密码、服务器地址等）
        
        Returns:
            bool: 是否连接成功
        """
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """
        断开连接
        
        Returns:
            bool: 是否断开成功
        """
        pass
    
    @abstractmethod
    def check_connection(self) -> bool:
        """
        检查连接状态
        
        Returns:
            bool: 是否连接正常
        """
        pass
    
    # ==================== 账户查询 ====================
    
    @abstractmethod
    def get_account(self) -> Optional[Account]:
        """
        获取账户信息
        
        Returns:
            Account: 账户信息
        """
        pass
    
    @abstractmethod
    def get_positions(self) -> List[Position]:
        """
        获取持仓列表
        
        Returns:
            List[Position]: 持仓列表
        """
        pass
    
    @abstractmethod
    def get_position(self, stock_code: str) -> Optional[Position]:
        """
        获取单个股票持仓
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Position: 持仓信息
        """
        pass
    
    # ==================== 订单管理 ====================
    
    @abstractmethod
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """
        下单
        
        Args:
            stock_code: 股票代码
            side: 买卖方向
            quantity: 数量
            price: 价格（市价单可不填）
            order_type: 订单类型
        
        Returns:
            str: 订单ID，失败返回None
        """
        pass
    
    @abstractmethod
    def cancel_order(self, order_id: str) -> bool:
        """
        撤单
        
        Args:
            order_id: 订单ID
        
        Returns:
            bool: 是否撤单成功
        """
        pass
    
    @abstractmethod
    def get_order(self, order_id: str) -> Optional[Order]:
        """
        获取订单信息
        
        Args:
            order_id: 订单ID
        
        Returns:
            Order: 订单信息
        """
        pass
    
    @abstractmethod
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """
        获取订单列表
        
        Args:
            status: 订单状态过滤
        
        Returns:
            List[Order]: 订单列表
        """
        pass
    
    @abstractmethod
    def get_trades(self) -> List[Dict]:
        """
        获取成交记录
        
        Returns:
            List[Dict]: 成交记录列表
        """
        pass
    
    # ==================== 行情数据 ====================
    
    @abstractmethod
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """
        获取实时行情
        
        Args:
            stock_code: 股票代码
        
        Returns:
            Dict: 行情数据
        """
        pass
    
    @abstractmethod
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """
        订阅实时行情
        
        Args:
            stock_codes: 股票代码列表
            callback: 行情回调函数
        
        Returns:
            bool: 是否订阅成功
        """
        pass
    
    @abstractmethod
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """
        取消订阅行情
        
        Args:
            stock_codes: 股票代码列表
        
        Returns:
            bool: 是否取消成功
        """
        pass
    
    # ==================== 回调注册 ====================
    
    def register_callback(self, event: str, callback: Callable):
        """
        注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks:
            self._callbacks[event].append(callback)
            logger.debug(f"注册回调: {event}")
    
    def unregister_callback(self, event: str, callback: Callable):
        """
        取消注册回调函数
        
        Args:
            event: 事件名称
            callback: 回调函数
        """
        if event in self._callbacks and callback in self._callbacks[event]:
            self._callbacks[event].remove(callback)
            logger.debug(f"取消回调: {event}")
    
    def _emit(self, event: str, *args, **kwargs):
        """
        触发回调
        
        Args:
            event: 事件名称
            *args, **kwargs: 回调参数
        """
        if event in self._callbacks:
            for callback in self._callbacks[event]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    logger.error(f"回调执行错误 [{event}]: {e}")
    
    # ==================== 便捷方法 ====================
    
    def buy(self, stock_code: str, quantity: int, price: float = 0.0, 
            order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """买入"""
        return self.place_order(stock_code, OrderSide.BUY, quantity, price, order_type)
    
    def sell(self, stock_code: str, quantity: int, price: float = 0.0,
             order_type: OrderType = OrderType.LIMIT) -> Optional[str]:
        """卖出"""
        return self.place_order(stock_code, OrderSide.SELL, quantity, price, order_type)
    
    def cancel_all_orders(self) -> int:
        """
        撤销所有活跃订单
        
        Returns:
            int: 成功撤销的订单数
        """
        cancelled = 0
        for order in self.get_orders():
            if order.is_active:
                if self.cancel_order(order.order_id):
                    cancelled += 1
        return cancelled
    
    def close_position(self, stock_code: str, price: float = 0.0) -> Optional[str]:
        """
        平仓
        
        Args:
            stock_code: 股票代码
            price: 卖出价格
        
        Returns:
            str: 订单ID
        """
        position = self.get_position(stock_code)
        if position and position.available > 0:
            return self.sell(stock_code, position.available, price)
        return None
    
    def close_all_positions(self) -> List[str]:
        """
        平掉所有持仓
        
        Returns:
            List[str]: 订单ID列表
        """
        order_ids = []
        for position in self.get_positions():
            if position.available > 0:
                order_id = self.close_position(position.stock_code)
                if order_id:
                    order_ids.append(order_id)
        return order_ids














