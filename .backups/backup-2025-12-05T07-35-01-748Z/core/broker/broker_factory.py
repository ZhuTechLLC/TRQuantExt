# -*- coding: utf-8 -*-
"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker






"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker




"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker

"""
券商工厂类
统一创建和管理券商接口实例
"""
from typing import Optional, Dict, Any
from enum import Enum
import logging

from .base import IBroker, BrokerStatus
from .qmt_broker import QMTBroker
from .ptrade_broker import PTradeBroker

logger = logging.getLogger(__name__)


class BrokerType(Enum):
    """券商类型"""
    QMT = "qmt"
    PTRADE = "ptrade"
    SIMULATION = "simulation"


class SimulationBroker(IBroker):
    """
    模拟券商接口
    用于策略开发和测试，不连接真实交易系统
    """
    
    def __init__(self, name: str = "Simulation"):
        super().__init__(name)
        self._initial_cash = 1000000.0
        self._cash = self._initial_cash
        self._commission_rate = 0.0003
        
    def connect(self, **kwargs) -> bool:
        self._initial_cash = kwargs.get('initial_cash', 1000000.0)
        self._cash = self._initial_cash
        self._commission_rate = kwargs.get('commission_rate', 0.0003)
        self._status = BrokerStatus.CONNECTED
        logger.info(f"模拟券商已连接，初始资金: {self._initial_cash}")
        self._emit('on_connected')
        return True
    
    def disconnect(self) -> bool:
        self._status = BrokerStatus.DISCONNECTED
        logger.info("模拟券商已断开")
        self._emit('on_disconnected')
        return True
    
    def check_connection(self) -> bool:
        return self._status == BrokerStatus.CONNECTED
    
    def get_account(self):
        from .base import Account
        market_value = sum(p.market_value for p in self._positions.values())
        return Account(
            account_id="SIMULATION",
            account_type="simulation",
            total_asset=self._cash + market_value,
            cash=self._cash,
            frozen=0,
            market_value=market_value,
        )
    
    def get_positions(self):
        return list(self._positions.values())
    
    def get_position(self, stock_code: str):
        return self._positions.get(stock_code)
    
    def place_order(self, stock_code, side, quantity, price=0.0, order_type=None):
        from .base import Order, OrderStatus, OrderSide, OrderType, Position
        import uuid
        
        order_id = str(uuid.uuid4())[:8]
        
        # 模拟立即成交
        if side == OrderSide.BUY:
            cost = price * quantity * (1 + self._commission_rate)
            if cost > self._cash:
                logger.warning(f"资金不足: 需要{cost}, 可用{self._cash}")
                return None
            
            self._cash -= cost
            
            if stock_code in self._positions:
                pos = self._positions[stock_code]
                total_cost = pos.cost_price * pos.quantity + price * quantity
                total_qty = pos.quantity + quantity
                pos.quantity = total_qty
                pos.available = total_qty
                pos.cost_price = total_cost / total_qty if total_qty > 0 else 0
            else:
                self._positions[stock_code] = Position(
                    stock_code=stock_code,
                    quantity=quantity,
                    available=quantity,
                    cost_price=price,
                    current_price=price,
                    market_value=price * quantity,
                )
        else:
            if stock_code not in self._positions:
                logger.warning(f"无持仓: {stock_code}")
                return None
            
            pos = self._positions[stock_code]
            if pos.available < quantity:
                logger.warning(f"可用数量不足: 需要{quantity}, 可用{pos.available}")
                return None
            
            revenue = price * quantity * (1 - self._commission_rate)
            self._cash += revenue
            
            pos.quantity -= quantity
            pos.available -= quantity
            
            if pos.quantity <= 0:
                del self._positions[stock_code]
        
        order = Order(
            order_id=order_id,
            stock_code=stock_code,
            side=side,
            order_type=order_type or OrderType.LIMIT,
            price=price,
            quantity=quantity,
            filled_quantity=quantity,
            filled_price=price,
            status=OrderStatus.FILLED,
        )
        self._orders[order_id] = order
        
        logger.info(f"模拟成交: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
        self._emit('on_order_update', order)
        
        return order_id
    
    def cancel_order(self, order_id: str) -> bool:
        if order_id in self._orders:
            order = self._orders[order_id]
            if order.is_active:
                from .base import OrderStatus
                order.status = OrderStatus.CANCELLED
                return True
        return False
    
    def get_order(self, order_id: str):
        return self._orders.get(order_id)
    
    def get_orders(self, status=None):
        orders = list(self._orders.values())
        if status:
            orders = [o for o in orders if o.status == status]
        return orders
    
    def get_trades(self):
        return []
    
    def get_quote(self, stock_code: str):
        return None
    
    def subscribe_quote(self, stock_codes, callback):
        return True
    
    def unsubscribe_quote(self, stock_codes):
        return True


class BrokerFactory:
    """
    券商工厂类
    
    统一创建和管理券商接口实例
    支持QMT、PTrade和模拟交易
    """
    
    _instances: Dict[str, IBroker] = {}
    
    @classmethod
    def create(
        cls,
        broker_type: BrokerType,
        name: str = None,
        **config
    ) -> Optional[IBroker]:
        """
        创建券商接口实例
        
        Args:
            broker_type: 券商类型
            name: 实例名称
            **config: 配置参数
        
        Returns:
            IBroker: 券商接口实例
        """
        if name is None:
            name = broker_type.value
        
        # 检查是否已存在实例
        if name in cls._instances:
            logger.warning(f"券商实例已存在: {name}")
            return cls._instances[name]
        
        # 创建实例
        broker = None
        
        if broker_type == BrokerType.QMT:
            broker = QMTBroker(name)
        elif broker_type == BrokerType.PTRADE:
            broker = PTradeBroker(name)
        elif broker_type == BrokerType.SIMULATION:
            broker = SimulationBroker(name)
        else:
            logger.error(f"不支持的券商类型: {broker_type}")
            return None
        
        cls._instances[name] = broker
        logger.info(f"创建券商实例: {name} ({broker_type.value})")
        
        return broker
    
    @classmethod
    def get(cls, name: str) -> Optional[IBroker]:
        """
        获取券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            IBroker: 券商接口实例
        """
        return cls._instances.get(name)
    
    @classmethod
    def remove(cls, name: str) -> bool:
        """
        移除券商接口实例
        
        Args:
            name: 实例名称
        
        Returns:
            bool: 是否移除成功
        """
        if name in cls._instances:
            broker = cls._instances[name]
            if broker.is_connected:
                broker.disconnect()
            del cls._instances[name]
            logger.info(f"移除券商实例: {name}")
            return True
        return False
    
    @classmethod
    def list_instances(cls) -> Dict[str, BrokerStatus]:
        """
        列出所有券商实例
        
        Returns:
            Dict[str, BrokerStatus]: 实例名称和状态
        """
        return {name: broker.status for name, broker in cls._instances.items()}
    
    @classmethod
    def connect_all(cls, configs: Dict[str, Dict]) -> Dict[str, bool]:
        """
        连接所有券商
        
        Args:
            configs: 配置字典 {name: config}
        
        Returns:
            Dict[str, bool]: 连接结果
        """
        results = {}
        for name, config in configs.items():
            broker = cls.get(name)
            if broker:
                results[name] = broker.connect(**config)
        return results
    
    @classmethod
    def disconnect_all(cls) -> None:
        """断开所有券商连接"""
        for name, broker in cls._instances.items():
            if broker.is_connected:
                broker.disconnect()
        logger.info("已断开所有券商连接")


# 便捷函数
def create_qmt_broker(
    path: str,
    account_id: str,
    session_id: int = 0,
    auto_connect: bool = True
) -> Optional[QMTBroker]:
    """
    创建并连接QMT券商
    
    Args:
        path: miniQMT安装路径
        account_id: 资金账号
        session_id: 会话ID
        auto_connect: 是否自动连接
    
    Returns:
        QMTBroker: QMT券商实例
    """
    broker = BrokerFactory.create(BrokerType.QMT, f"QMT_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            path=path,
            account_id=account_id,
            session_id=session_id
        )
        if not success:
            logger.error("QMT连接失败")
            return None
    
    return broker


def create_ptrade_broker(
    host: str,
    port: int,
    account_id: str,
    password: str,
    auto_connect: bool = True
) -> Optional[PTradeBroker]:
    """
    创建并连接PTrade券商
    
    Args:
        host: 服务器地址
        port: 端口号
        account_id: 资金账号
        password: 密码
        auto_connect: 是否自动连接
    
    Returns:
        PTradeBroker: PTrade券商实例
    """
    broker = BrokerFactory.create(BrokerType.PTRADE, f"PTrade_{account_id}")
    
    if broker and auto_connect:
        success = broker.connect(
            host=host,
            port=port,
            account_id=account_id,
            password=password
        )
        if not success:
            logger.error("PTrade连接失败")
            return None
    
    return broker


def create_simulation_broker(
    initial_cash: float = 1000000.0,
    commission_rate: float = 0.0003
) -> SimulationBroker:
    """
    创建模拟券商
    
    Args:
        initial_cash: 初始资金
        commission_rate: 手续费率
    
    Returns:
        SimulationBroker: 模拟券商实例
    """
    broker = BrokerFactory.create(BrokerType.SIMULATION, "Simulation")
    
    if broker:
        broker.connect(
            initial_cash=initial_cash,
            commission_rate=commission_rate
        )
    
    return broker














