# -*- coding: utf-8 -*-
"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)






"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)




"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)

"""
PTrade券商接口实现
基于恒生PTrade系统的Python接口

接口文档：http://180.169.107.9:7766/hub/help/api?weworkcfmcode
PTrade策略编译环境：Python 3.11
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import json
import time
import hashlib
import hmac
import requests

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class PTradeBroker(IBroker):
    """
    PTrade券商接口
    
    通过HTTP API连接PTrade系统进行交易
    支持股票、ETF等A股交易品种
    """
    
    # PTrade订单状态映射
    PTRADE_ORDER_STATUS_MAP = {
        '0': OrderStatus.PENDING,        # 未报
        '1': OrderStatus.SUBMITTED,      # 待报
        '2': OrderStatus.SUBMITTED,      # 已报
        '3': OrderStatus.SUBMITTED,      # 已报待撤
        '4': OrderStatus.PARTIAL_FILLED, # 部成待撤
        '5': OrderStatus.PARTIAL_FILLED, # 部撤
        '6': OrderStatus.CANCELLED,      # 已撤
        '7': OrderStatus.PARTIAL_FILLED, # 部成
        '8': OrderStatus.FILLED,         # 已成
        '9': OrderStatus.REJECTED,       # 废单
    }
    
    def __init__(self, name: str = "PTrade"):
        super().__init__(name)
        self._base_url = ""
        self._account_id = ""
        self._token = ""
        self._session = requests.Session()
        self._quote_ws = None
        self._quote_callback = None
        
    def connect(
        self,
        host: str = "",
        port: int = 8888,
        account_id: str = "",
        password: str = "",
        **kwargs
    ) -> bool:
        """
        连接PTrade
        
        Args:
            host: 服务器地址
            port: 端口号
            account_id: 资金账号
            password: 密码
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            self._base_url = f"http://{host}:{port}"
            self._account_id = account_id
            
            logger.info(f"正在连接PTrade: {self._base_url}, account={account_id}")
            
            # 登录认证
            login_data = {
                'account_id': account_id,
                'password': self._encrypt_password(password),
                'client_type': 'api',
            }
            
            response = self._request('POST', '/api/login', data=login_data)
            
            if response and response.get('code') == 0:
                self._token = response.get('data', {}).get('token', '')
                self._session.headers.update({
                    'Authorization': f'Bearer {self._token}'
                })
                
                self._status = BrokerStatus.CONNECTED
                logger.info("PTrade连接成功")
                self._emit('on_connected')
                return True
            else:
                error_msg = response.get('message', '登录失败') if response else '连接失败'
                logger.error(f"PTrade登录失败: {error_msg}")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', error_msg)
                return False
                
        except Exception as e:
            logger.error(f"PTrade连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开PTrade连接"""
        try:
            if self._token:
                self._request('POST', '/api/logout')
            
            self._token = ""
            self._session.headers.pop('Authorization', None)
            self._status = BrokerStatus.DISCONNECTED
            
            logger.info("PTrade已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开PTrade连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        if self._status != BrokerStatus.CONNECTED:
            return False
        
        try:
            response = self._request('GET', '/api/heartbeat')
            return response and response.get('code') == 0
        except:
            return False
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', '/api/account/asset')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=float(data.get('total_asset', 0)),
                    cash=float(data.get('available_cash', 0)),
                    frozen=float(data.get('frozen_cash', 0)),
                    market_value=float(data.get('market_value', 0)),
                    profit=float(data.get('profit', 0)),
                    profit_ratio=float(data.get('profit_ratio', 0)),
                )
                self._emit('on_account_update', self._account)
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/account/positions')
            
            if response and response.get('code') == 0:
                positions = response.get('data', [])
                result = []
                
                for pos in positions:
                    position = Position(
                        stock_code=pos.get('stock_code', ''),
                        stock_name=pos.get('stock_name', ''),
                        quantity=int(pos.get('volume', 0)),
                        available=int(pos.get('available_volume', 0)),
                        cost_price=float(pos.get('cost_price', 0)),
                        current_price=float(pos.get('current_price', 0)),
                        market_value=float(pos.get('market_value', 0)),
                        profit=float(pos.get('profit', 0)),
                        profit_ratio=float(pos.get('profit_ratio', 0)),
                    )
                    self._positions[position.stock_code] = position
                    result.append(position)
                
                self._emit('on_position_update', result)
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.is_connected:
            logger.error("未连接PTrade，无法下单")
            return None
        
        try:
            # 构建订单数据
            order_data = {
                'stock_code': stock_code,
                'side': 'B' if side == OrderSide.BUY else 'S',
                'volume': quantity,
                'price': price,
                'price_type': self._convert_order_type(order_type),
            }
            
            response = self._request('POST', '/api/order/place', data=order_data)
            
            if response and response.get('code') == 0:
                order_id = response.get('data', {}).get('order_id', '')
                
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                error_msg = response.get('message', '下单失败') if response else '请求失败'
                logger.error(f"下单失败: {error_msg}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.is_connected:
            return False
        
        try:
            response = self._request('POST', '/api/order/cancel', data={'order_id': order_id})
            
            if response and response.get('code') == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                error_msg = response.get('message', '撤单失败') if response else '请求失败'
                logger.error(f"撤单失败: {error_msg}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if not self.is_connected:
            return self._orders.get(order_id)
        
        try:
            response = self._request('GET', f'/api/order/{order_id}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                order = self._parse_order(data)
                self._orders[order_id] = order
                return order
            return self._orders.get(order_id)
            
        except Exception as e:
            logger.error(f"获取订单信息失败: {e}")
            return self._orders.get(order_id)
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.is_connected:
            orders = list(self._orders.values())
            if status:
                orders = [o for o in orders if o.status == status]
            return orders
        
        try:
            response = self._request('GET', '/api/orders')
            
            if response and response.get('code') == 0:
                orders_data = response.get('data', [])
                result = []
                
                for data in orders_data:
                    order = self._parse_order(data)
                    self._orders[order.order_id] = order
                    
                    if status is None or order.status == status:
                        result.append(order)
                
                return result
            return list(self._orders.values())
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.is_connected:
            return []
        
        try:
            response = self._request('GET', '/api/trades')
            
            if response and response.get('code') == 0:
                trades = response.get('data', [])
                result = []
                
                for t in trades:
                    result.append({
                        'trade_id': t.get('trade_id', ''),
                        'order_id': t.get('order_id', ''),
                        'stock_code': t.get('stock_code', ''),
                        'side': 'buy' if t.get('side') == 'B' else 'sell',
                        'price': float(t.get('price', 0)),
                        'quantity': int(t.get('volume', 0)),
                        'amount': float(t.get('amount', 0)),
                        'time': t.get('trade_time', ''),
                    })
                
                return result
            return []
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        if not self.is_connected:
            return None
        
        try:
            response = self._request('GET', f'/api/quote/{stock_code}')
            
            if response and response.get('code') == 0:
                data = response.get('data', {})
                return {
                    'code': stock_code,
                    'price': float(data.get('last_price', 0)),
                    'open': float(data.get('open', 0)),
                    'high': float(data.get('high', 0)),
                    'low': float(data.get('low', 0)),
                    'volume': int(data.get('volume', 0)),
                    'amount': float(data.get('amount', 0)),
                    'bid_price': data.get('bid_price', []),
                    'ask_price': data.get('ask_price', []),
                    'bid_volume': data.get('bid_volume', []),
                    'ask_volume': data.get('ask_volume', []),
                    'time': data.get('time', ''),
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        # PTrade的行情订阅通常通过WebSocket实现
        # 这里提供基础框架，具体实现需要根据PTrade版本调整
        self._quote_callback = callback
        logger.info(f"订阅行情: {stock_codes}")
        return True
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        logger.info(f"取消订阅行情: {stock_codes}")
        return True
    
    # ==================== 私有方法 ====================
    
    def _request(self, method: str, endpoint: str, data: Dict = None) -> Optional[Dict]:
        """发送HTTP请求"""
        try:
            url = f"{self._base_url}{endpoint}"
            
            if method == 'GET':
                response = self._session.get(url, params=data, timeout=10)
            else:
                response = self._session.post(url, json=data, timeout=10)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"请求异常: {e}")
            return None
        except json.JSONDecodeError:
            logger.error(f"响应解析失败: {endpoint}")
            return None
    
    def _encrypt_password(self, password: str) -> str:
        """加密密码"""
        # PTrade通常使用MD5或其他加密方式
        # 具体加密方式需要根据PTrade版本调整
        return hashlib.md5(password.encode()).hexdigest()
    
    def _convert_order_type(self, order_type: OrderType) -> str:
        """转换订单类型"""
        if order_type == OrderType.MARKET:
            return '0'  # 市价
        elif order_type == OrderType.BEST:
            return '1'  # 最优五档
        else:
            return '2'  # 限价
    
    def _parse_order(self, data: Dict) -> Order:
        """解析订单数据"""
        status_code = str(data.get('status', '0'))
        status = self.PTRADE_ORDER_STATUS_MAP.get(status_code, OrderStatus.UNKNOWN)
        
        return Order(
            order_id=str(data.get('order_id', '')),
            stock_code=data.get('stock_code', ''),
            side=OrderSide.BUY if data.get('side') == 'B' else OrderSide.SELL,
            order_type=OrderType.LIMIT,
            price=float(data.get('price', 0)),
            quantity=int(data.get('volume', 0)),
            filled_quantity=int(data.get('filled_volume', 0)),
            filled_price=float(data.get('filled_price', 0)),
            status=status,
            message=data.get('message', ''),
        )


class PTradeStrategyRunner:
    """
    PTrade策略运行器
    
    用于在PTrade环境中运行策略
    PTrade策略编译环境：Python 3.11
    """
    
    def __init__(self, broker: PTradeBroker):
        self.broker = broker
        self._running = False
        self._strategy = None
    
    def set_strategy(self, strategy):
        """设置策略"""
        self._strategy = strategy
    
    def start(self):
        """启动策略"""
        if not self.broker.is_connected:
            logger.error("券商未连接，无法启动策略")
            return False
        
        if self._strategy is None:
            logger.error("未设置策略")
            return False
        
        self._running = True
        logger.info("策略已启动")
        
        # 初始化策略
        if hasattr(self._strategy, 'on_init'):
            self._strategy.on_init()
        
        return True
    
    def stop(self):
        """停止策略"""
        self._running = False
        
        if self._strategy and hasattr(self._strategy, 'on_stop'):
            self._strategy.on_stop()
        
        logger.info("策略已停止")
    
    def on_bar(self, bar_data: Dict):
        """K线数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_bar'):
            self._strategy.on_bar(bar_data)
    
    def on_tick(self, tick_data: Dict):
        """Tick数据回调"""
        if not self._running or self._strategy is None:
            return
        
        if hasattr(self._strategy, 'on_tick'):
            self._strategy.on_tick(tick_data)














